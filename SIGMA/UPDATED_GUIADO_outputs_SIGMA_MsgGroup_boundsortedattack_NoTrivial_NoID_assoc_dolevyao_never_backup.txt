Authenticating with public key "rsa-key-20250129"
    ┌──────────────────────────────────────────────────────────────────────┐
    │                 • MobaXterm Personal Edition v25.0 •                 │
    │               (SSH client, X server and network tools)               │
    │                                                                      │
    │ ⮞ SSH session to ahernandez@safe-trust.dsic.upv.es                   │
    │   • Direct SSH      :  ✓                                             │
    │   • SSH compression :  ✓                                             │
    │   • SSH-browser     :  ✓                                             │
    │   • X11-forwarding  :  ✓  (remote display is forwarded through SSH)  │
    │                                                                      │
    │ ⮞ For more info, ctrl+click on help or visit our website.            │
    └──────────────────────────────────────────────────────────────────────┘

Welcome to Ubuntu 24.04.2 LTS (GNU/Linux 6.8.0-56-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/pro

 System information as of Thu Apr 17 01:41:21 PM CEST 2025

  System load:  8.16                Temperature:           43.0 C
  Usage of /:   13.5% of 438.52GB   Processes:             380
  Memory usage: 17%                 Users logged in:       1
  Swap usage:   0%                  IPv4 address for eno5: 158.42.186.56
*** System restart required ***
ahernandez@safe-trust:~$ cd maude-npa
ahernandez@safe-trust:~/maude-npa$ cd Github_Hah
-bash: cd: Github_Hah: No such file or directory
ahernandez@safe-trust:~/maude-npa$ cd Github_Hash
ahernandez@safe-trust:~/maude-npa/Github_Hash$ maude
                     \||||||||||||||||||/
                   --- Welcome to Maude ---
                     /||||||||||||||||||\
             Maude 3.5 built: Sep 25 2024 12:00:00
             Copyright 1997-2024 SRI International
                   Thu Apr 17 13:41:45 2025
Maude> load maude-npa
Advisory: "maude-npa.maude", line 14352 (fmod BACK-NARROWING): all the variables in the left-hand side of assignment condition fragment
    M:Msg := downMsgSet(getTerm(metaReduce(removeVariantLabel(clearNonExecEqs(eraseRls(onlyEqsNoBuiltInUnify(flipRls(
    STRAND-EXAMPLE-RULES))))), upTerm(M':Msg)))) are bound before the matching takes place.
Advisory: "maude-npa.maude", line 14376 (fmod BACK-NARROWING): all the variables in the left-hand side of assignment condition fragment
    M:Msg := downMsgSet(getTerm(metaReduce(removeVariantLabel(clearNonExecEqs(eraseRls(onlyEqsNoBuiltInUnify(flipRls(
    STRAND-EXAMPLE-RULES))))), upTerm(M':Msg)))) are bound before the matching takes place.
Advisory: "maude-npa.maude", line 14392 (fmod BACK-NARROWING): all the variables in the left-hand side of assignment condition fragment
    M:Msg := downMsgSet(getTerm(metaReduce(removeVariantLabel(clearNonExecEqs(eraseRls(onlyEqsNoBuiltInUnify(flipRls(
    STRAND-EXAMPLE-RULES))))), upTerm(M:Msg)))) are bound before the matching takes place.

            Maude-NPA Version: 3.1.4 (June 2nd 2020)
            with direct composition, irreducibility constraints and time
            (To be run with Maude 3.0 or above)
            Copyright (c) 2020, University of Illinois
            All rights reserved.

 Commands:
 red unification? .           returns the unification algorithm to be used
 red new-strands? .           returns the actual protocol strands
 red displayGrammars .        for generating grammars
 red run(X,Y).                for Y backwards analysis steps for attack pattern X
 red debug(X,Y).              more information than run command
 red digest(X,Y).             less information than run command
 red summary(X,Y).            for summary of analysis steps
 red ids(X,Y).                for set of state ids
 red initials(X,Y).           for showing only initial steps
Maude> load SIGMA_attack_cpi_colExt.maude
Maude> red initials[1 . 3 . 1 . 2 . 6 . 7 . 2 . 8 . 8 . 10 . 6 . 1](4,11) .
reduce in MAUDE-NPA : initials[1 . 3 . 1 . 2 . 6 . 7 . 2 . 8 . 8 . 10 . 6 . 1](4, 11) .
rewrites: 28218762 in 28138ms cpu (28137ms real) (1002870 rewrites/second)
result IdSystemSet: (empty).IdSystemSet
Maude> red summary[1 . 3 . 1 . 2 . 6 . 7 . 2 . 8 . 8 . 10 . 6 . 1](4,11) .
reduce in MAUDE-NPA : summary[1 . 3 . 1 . 2 . 6 . 7 . 2 . 8 . 8 . 10 . 6 . 1](4, 11) .
rewrites: 508 in 1ms cpu (1ms real) (508000 rewrites/second)
result Summary: States>> 0 Solutions>> 0
Maude> red run(4,1) .
reduce in MAUDE-NPA : run(4, 1) .
rewrites: 1661404 in 831ms cpu (831ms real) (1999282 rewrites/second)
result IdSystemSet: (< 1 . 1 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; #2:MsgElem ; #3:MsgElem ; #4:MsgElem),
   +(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp ; #2:MsgElem ; #3:MsgElem ; #4:MsgElem))) |
   -(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp ; #2:MsgElem ; #3:MsgElem ; #4:MsgElem))),
   +(ok), nil]  &
:: #5:Fresh ::
[ nil,
   -(#6:Exp ; #7:MsgElem),
   +(exp(g, n(b, #5:Fresh)) ; b),
   -(sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
   +(sign(sk(b), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))) |
   -(ok), nil] )
|
ok !inI,
sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp ; #2:MsgElem ; #3:MsgElem ; #4:MsgElem)) inI
|
-(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp ; #2:MsgElem ; #3:MsgElem ; #4:MsgElem))),
+(ok),
-(ok)
|
nil)
(< 1 . 3 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem),
   +(sign(sk(a), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))) |
   -(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
   +(ok), nil]  &
:: #5:Fresh ::
[ nil,
   -(#6:Exp ; #7:MsgElem),
   +(exp(g, n(b, #5:Fresh)) ; b),
   -(sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
   +(sign(sk(b), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))) |
   -(ok), nil] )
|
ok !inI,
sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem)) inI
|
-(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
+(ok),
-(ok)
|
nil)
(< 1 . 5 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; #2:MsgElem ; #3:MsgElem ; #4:MsgElem),
   +(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp ; #2:MsgElem ; #3:MsgElem ; #4:MsgElem))),
   -(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp ; #2:MsgElem ; #3:MsgElem ; #4:MsgElem))),
   +(ok) | nil]  &
:: #5:Fresh ::
[ nil,
   -(#6:Exp ; #7:MsgElem),
   +(exp(g, n(b, #5:Fresh)) ; b) |
   -(sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
   +(sign(sk(b), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
   -(ok), nil] )
|
ok inI,
sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b)) inI
|
-(sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
+(sign(sk(b), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
-(ok)
|
nil)
(< 1 . 6 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem),
   +(sign(sk(a), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
   -(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
   +(ok) | nil]  &
:: #5:Fresh ::
[ nil,
   -(#6:Exp ; #7:MsgElem),
   +(exp(g, n(b, #5:Fresh)) ; b) |
   -(sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
   +(sign(sk(b), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
   -(ok), nil] )
|
ok inI,
sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b)) inI
|
-(sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
+(sign(sk(b), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
-(ok)
|
nil)
(< 1 . 13 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; #2:MsgElem ; #3:MsgElem ; #4:MsgElem),
   +(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp ; #2:MsgElem ; #3:MsgElem ; #4:MsgElem))),
   -(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp ; #2:MsgElem ; #3:MsgElem ; #4:MsgElem))),
   +(ok) | nil]  &
:: #5:Fresh ::
[ nil,
   -(#6:Exp ; #7:MsgElem),
   +(exp(g, n(b, #5:Fresh)) ; b),
   -(sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
   +(sign(sk(b), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))) |
   -(ok), nil]  &
:: #8:Fresh ::
[ nil,
   +(exp(g, n(#9:Name, #8:Fresh)) ; #9:Name),
   -(#10:Exp ; #11:Msg),
   +(sign(sk(#9:Name), H(exp(g, n(#9:Name, #8:Fresh)) ; #9:Name ; #10:Exp ; #11:Msg))),
   -(sign(sk(#12:Name), #13:Hash)),
   H(exp(g, n(#9:Name, #8:Fresh)) ; #9:Name ; #10:Exp ; #11:Msg) eq #13:Hash |
   +(ok), nil] )
|
ok !inI
|
+(ok),
-(ok)
|
nil)
< 1 . 14 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem),
   +(sign(sk(a), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
   -(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
   +(ok) | nil]  &
:: #5:Fresh ::
[ nil,
   -(#6:Exp ; #7:MsgElem),
   +(exp(g, n(b, #5:Fresh)) ; b),
   -(sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
   +(sign(sk(b), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))) |
   -(ok), nil]  &
:: #8:Fresh ::
[ nil,
   +(exp(g, n(#9:Name, #8:Fresh)) ; #9:Name),
   -(#10:Exp ; #11:Msg),
   +(sign(sk(#9:Name), H(exp(g, n(#9:Name, #8:Fresh)) ; #9:Name ; #10:Exp ; #11:Msg))),
   -(sign(sk(#12:Name), #13:Hash)),
   H(exp(g, n(#9:Name, #8:Fresh)) ; #9:Name ; #10:Exp ; #11:Msg) eq #13:Hash |
   +(ok), nil] )
|
ok !inI
|
+(ok),
-(ok)
|
nil
Maude> red run[1 . 3](4,1) .
reduce in MAUDE-NPA : run[1 . 3](4, 1) .
rewrites: 1661445 in 810ms cpu (809ms real) (2051166 rewrites/second)
result ShortIdSystem: < 1 . 3 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem),
   +(sign(sk(a), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))) |
   -(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
   +(ok), nil]  &
:: #5:Fresh ::
[ nil,
   -(#6:Exp ; #7:MsgElem),
   +(exp(g, n(b, #5:Fresh)) ; b),
   -(sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
   +(sign(sk(b), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))) |
   -(ok), nil] )
|
ok !inI,
sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem)) inI
|
-(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
+(ok),
-(ok)
|
nil
Maude> red run[1 . 3](4,2) .
reduce in MAUDE-NPA : run[1 . 3](4, 2) .
rewrites: 1182712 in 644ms cpu (644ms real) (1836509 rewrites/second)
result IdSystemSet: (< 1 . 3 . 1 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a) |
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem),
   +(sign(sk(a), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
   -(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
   +(ok), nil]  &
:: #5:Fresh ::
[ nil,
   -(#6:Exp ; #7:MsgElem),
   +(exp(g, n(b, #5:Fresh)) ; b),
   -(sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
   +(sign(sk(b), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))) |
   -(ok), nil] )
|
ok !inI,
(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem) inI,
sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem)) inI
|
-(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem),
+(sign(sk(a), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
-(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
+(ok),
-(ok)
|
nil)
(< 1 . 3 . 2 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
   +(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))) |
   -(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   +(ok), nil]  &
:: #3:Fresh ::
[ nil,
   -(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp)),
   +(exp(g, n(b, #3:Fresh)) ; b) |
   -(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   +(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   -(ok), nil] )
|
ok !inI,
sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b)) !inI,
sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b)) inI
|
-(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
+(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
-(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
+(ok),
-(ok)
|
nil)
(< 1 . 3 . 3 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem),
   +(sign(sk(a), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))) |
   -(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
   +(ok), nil]  &
:: #5:Fresh ::
[ nil,
   -(#6:Exp ; #7:MsgElem),
   +(exp(g, n(b, #5:Fresh)) ; b) |
   -(sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
   +(sign(sk(b), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
   -(ok), nil] )
|
ok !inI,
sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b)) inI,
sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem)) inI
|
-(sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
+(sign(sk(b), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
-(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; #3:MsgElem ; #4:MsgElem))),
+(ok),
-(ok)
|
nil)
(< 1 . 3 . 7 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
   +(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))) |
   -(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   +(ok), nil]  &
:: #3:Fresh ::
[ nil,
   -(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp)),
   +(exp(g, n(b, #3:Fresh)) ; b),
   -(sign(sk(#7:Name), #8:Hash)),
   #8:Hash eq H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b) |
   +(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))), nil]  &
:: #4:Fresh ::
[ nil,
   -(#5:Exp ; #6:MsgElem),
   +(exp(g, n(b, #4:Fresh)) ; b),
   -(sign(sk(a), H(#5:Exp ; #6:MsgElem ; exp(g, n(b, #4:Fresh)) ; b))),
   +(sign(sk(b), H(#5:Exp ; #6:MsgElem ; exp(g, n(b, #4:Fresh)) ; b))) |
   -(ok), nil] )
|
ok !inI,
sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b)) !inI
|
+(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
-(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
+(ok),
-(ok)
|
nil)
< 1 . 3 . 8 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; exp(g, n(b, #3:Fresh)) ; b),
   +(sign(sk(a), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; exp(g, n(b, #3:Fresh)) ; b))) |
   -(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; exp(g, n(b, #3:Fresh)) ; b))),
   +(ok), nil]  &
:: #3:Fresh ::
[ nil,
   -(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem)),
   +(exp(g, n(b, #3:Fresh)) ; b),
   -(sign(sk(#7:Name), #8:Hash)),
   #8:Hash eq H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; exp(g, n(b, #3:Fresh)) ; b) |
   +(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; exp(g, n(b, #3:Fresh)) ; b))), nil]  &
:: #4:Fresh ::
[ nil,
   -(#5:Exp ; #6:MsgElem),
   +(exp(g, n(b, #4:Fresh)) ; b),
   -(sign(sk(a), H(#5:Exp ; #6:MsgElem ; exp(g, n(b, #4:Fresh)) ; b))),
   +(sign(sk(b), H(#5:Exp ; #6:MsgElem ; exp(g, n(b, #4:Fresh)) ; b))) |
   -(ok), nil] )
|
ok !inI,
sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; exp(g, n(b, #3:Fresh)) ; b)) !inI
|
+(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; exp(g, n(b, #3:Fresh)) ; b))),
-(sign(sk(b), H(#2:MsgElem ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:MsgElem) ; exp(g, n(b, #3:Fresh)) ; b))),
+(ok),
-(ok)
|
nil
Maude> red run[1 . 3 . 7](4,2) .
reduce in MAUDE-NPA : run[1 . 3 . 7](4, 2) .
rewrites: 2843983 in 1436ms cpu (1435ms real) (1980489 rewrites/second)
result ShortIdSystem: < 1 . 3 . 7 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
   +(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))) |
   -(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   +(ok), nil]  &
:: #3:Fresh ::
[ nil,
   -(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp)),
   +(exp(g, n(b, #3:Fresh)) ; b),
   -(sign(sk(#7:Name), #8:Hash)),
   #8:Hash eq H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b) |
   +(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))), nil]  &
:: #4:Fresh ::
[ nil,
   -(#5:Exp ; #6:MsgElem),
   +(exp(g, n(b, #4:Fresh)) ; b),
   -(sign(sk(a), H(#5:Exp ; #6:MsgElem ; exp(g, n(b, #4:Fresh)) ; b))),
   +(sign(sk(b), H(#5:Exp ; #6:MsgElem ; exp(g, n(b, #4:Fresh)) ; b))) |
   -(ok), nil] )
|
ok !inI,
sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b)) !inI
|
+(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
-(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
+(ok),
-(ok)
|
nil
Maude> red run[1 . 3 . 7](4,3) .
reduce in MAUDE-NPA : run[1 . 3 . 7](4, 3) .
rewrites: 916430 in 605ms cpu (604ms real) (1514760 rewrites/second)
result IdSystemSet: (< 1 . 3 . 7 . 1 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a) |
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
   +(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   -(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   +(ok), nil]  &
:: #3:Fresh ::
[ nil,
   -(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp)),
   +(exp(g, n(b, #3:Fresh)) ; b),
   -(sign(sk(#4:Name), #5:Hash)),
   #5:Hash eq H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b) |
   +(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))), nil]  &
:: #6:Fresh ::
[ nil,
   -(#7:Exp ; #8:MsgElem),
   +(exp(g, n(b, #6:Fresh)) ; b),
   -(sign(sk(a), H(#7:Exp ; #8:MsgElem ; exp(g, n(b, #6:Fresh)) ; b))),
   +(sign(sk(b), H(#7:Exp ; #8:MsgElem ; exp(g, n(b, #6:Fresh)) ; b))) |
   -(ok), nil] )
|
ok !inI,
sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b)) !inI,
(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b) inI
|
-(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
+(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
+(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
-(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
+(ok),
-(ok)
|
nil)
(< 1 . 3 . 7 . 2 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
   +(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))) |
   -(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   +(ok), nil]  &
:: #3:Fresh ::
[ nil,
   -(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp)),
   +(exp(g, n(b, #3:Fresh)) ; b) |
   -(sign(sk(#4:Name), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b) eq H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ;
    a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
   +(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))), nil]  &
:: #5:Fresh ::
[ nil,
   -(#6:Exp ; #7:MsgElem),
   +(exp(g, n(b, #5:Fresh)) ; b),
   -(sign(sk(a), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))),
   +(sign(sk(b), H(#6:Exp ; #7:MsgElem ; exp(g, n(b, #5:Fresh)) ; b))) |
   -(ok), nil] )
|
ok !inI,
sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b)) !inI,
sign(sk(#4:Name), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b)) inI
|
-(sign(sk(#4:Name), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
+(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
-(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
+(ok),
-(ok)
|
nil)
< 1 . 3 . 7 . 3 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a),
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
   +(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))) |
   -(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   +(ok), nil]  &
:: #3:Fresh ::
[ nil,
   -(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp)),
   +(exp(g, n(b, #3:Fresh)) ; b),
   -(sign(sk(#4:Name), #5:Hash)),
   #5:Hash eq H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b) |
   +(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))), nil]  &
:: #6:Fresh ::
[ nil,
   -(#7:Exp ; #8:MsgElem),
   +(exp(g, n(b, #6:Fresh)) ; b) |
   -(sign(sk(a), H(#7:Exp ; #8:MsgElem ; exp(g, n(b, #6:Fresh)) ; b))),
   +(sign(sk(b), H(#7:Exp ; #8:MsgElem ; exp(g, n(b, #6:Fresh)) ; b))),
   -(ok), nil] )
|
ok !inI,
sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b)) !inI,
sign(sk(a), H(#7:Exp ; #8:MsgElem ; exp(g, n(b, #6:Fresh)) ; b)) inI
|
-(sign(sk(a), H(#7:Exp ; #8:MsgElem ; exp(g, n(b, #6:Fresh)) ; b))),
+(sign(sk(b), H(#7:Exp ; #8:MsgElem ; exp(g, n(b, #6:Fresh)) ; b))),
+(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
-(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
+(ok),
-(ok)
|
nil
Maude> red run[1 . 3 . 2](4,3) .
reduce in MAUDE-NPA : run[1 . 3 . 2](4, 3) .
rewrites: 3330426 in 1877ms cpu (1877ms real) (1774334 rewrites/second)
result ShortIdSystem: < 1 . 3 . 2 . 1 > (
:: #0:Fresh ::
[ nil,
   +(exp(g, n(a, #0:Fresh)) ; a) |
   -(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
   +(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   -(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   +(ok), nil]  &
:: #3:Fresh ::
[ nil,
   -(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp)),
   +(exp(g, n(b, #3:Fresh)) ; b) |
   -(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   +(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   -(ok), nil] )
|
ok !inI,
sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b)) !inI,
sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b)) !inI,
(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b) inI
|
-(#1:Exp ; cp1(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
+(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
-(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
+(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
-(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #0:Fresh)) ; a ; #1:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
+(ok),
-(ok)
|
nil
Maude> red summary[1 . 3 . 2](4,3) .
reduce in MAUDE-NPA : summary[1 . 3 . 2](4, 3) .
rewrites: 327 in 1ms cpu (1ms real) (327000 rewrites/second)
result Summary: States>> 1 Solutions>> 0
Maude> red summary[1 . 3 . 2](4,4) .
reduce in MAUDE-NPA : summary[1 . 3 . 2](4, 4) .
rewrites: 1255385 in 941ms cpu (941ms real) (1334096 rewrites/second)
result Summary: States>> 3 Solutions>> 0
Maude> red summary[1 . 3 . 2](4,5) .
reduce in MAUDE-NPA : summary[1 . 3 . 2](4, 5) .
rewrites: 3741386 in 2712ms cpu (2711ms real) (1379567 rewrites/second)
result Summary: States>> 4 Solutions>> 0
Maude> red summary[1 . 3 . 2](4,6) .
reduce in MAUDE-NPA : summary[1 . 3 . 2](4, 6) .
rewrites: 5953517 in 4213ms cpu (4213ms real) (1413130 rewrites/second)
result Summary: States>> 6 Solutions>> 0
Maude> red summary[1 . 3 . 2](4,7) .
reduce in MAUDE-NPA : summary[1 . 3 . 2](4, 7) .
rewrites: 15150935 in 9269ms cpu (9269ms real) (1634581 rewrites/second)
result Summary: States>> 8 Solutions>> 0
Maude> red summary[1 . 3 . 2](4,8) .
reduce in MAUDE-NPA : summary[1 . 3 . 2](4, 8) .
rewrites: 22539155 in 13008ms cpu (13008ms real) (1732714 rewrites/second)
result Summary: States>> 5 Solutions>> 0
Maude> red summary[1 . 3 . 2](4,9) .
reduce in MAUDE-NPA : summary[1 . 3 . 2](4, 9) .
rewrites: 10919481 in 7805ms cpu (7805ms real) (1399036 rewrites/second)
result Summary: States>> 1 Solutions>> 0
Maude> red summary[1 . 3 . 2](4,10) .
reduce in MAUDE-NPA : summary[1 . 3 . 2](4, 10) .
rewrites: 2059497 in 1081ms cpu (1080ms real) (1905177 rewrites/second)
result Summary: States>> 2 Solutions>> 0
Maude> red summary[1 . 3 . 2](4,11) .
reduce in MAUDE-NPA : summary[1 . 3 . 2](4, 11) .
rewrites: 4474152 in 2036ms cpu (2036ms real) (2197520 rewrites/second)
result Summary: States>> 3 Solutions>> 1
Maude> red initials[1 . 3 . 2](4,11) .
reduce in MAUDE-NPA : initials[1 . 3 . 2](4, 11) .
rewrites: 1305 in 2ms cpu (2ms real) (652500 rewrites/second)
result ShortIdSystem: < 1 . 3 . 2 . 1 . 6 . 7 . 2 . 8 . 8 . 10 . 6 . 1 > (
:: nil ::
[ nil |
   -(#2:Exp),
   -(cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp)),
   +(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp)), nil]  &
:: nil ::
[ nil |
   -(#0:Exp),
   -(cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
   +(#0:Exp ; cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b), nil]  &
:: nil ::
[ nil |
   -(exp(g, n(a, #1:Fresh)) ; a),
   -(#0:Exp),
   +(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp), nil]  &
:: nil ::
[ nil |
   -(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp),
   -(#2:Exp),
   +(cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp)), nil]  &
:: nil ::
[ nil |
   -(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp),
   -(#2:Exp),
   +(cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp)), nil]  &
:: nil ::
[ nil |
   -(cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp)),
   -(exp(g, n(b, #3:Fresh)) ; b),
   +(cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b), nil]  &
:: #1:Fresh ::
[ nil |
   +(exp(g, n(a, #1:Fresh)) ; a),
   -(#0:Exp ; cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
   +(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   -(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   +(ok), nil]  &
:: #3:Fresh ::
[ nil |
   -(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp)),
   +(exp(g, n(b, #3:Fresh)) ; b),
   -(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   +(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
   -(ok), nil] )
|
ok !inI,
#2:Exp !inI,
#0:Exp !inI,
(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp)) !inI,
(exp(g, n(a, #1:Fresh)) ; a) !inI,
(exp(g, n(b, #3:Fresh)) ; b) !inI,
(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp) !inI,
(cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b) !inI,
(#0:Exp ; cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b) !inI,
sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b)) !inI,
sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b)) !inI,
cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) !inI,
cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) !inI
|
+(exp(g, n(a, #1:Fresh)) ; a),
generatedByIntruder(#0:Exp),
-(exp(g, n(a, #1:Fresh)) ; a),
-(#0:Exp),
+(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp),
generatedByIntruder(#2:Exp),
-(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp),
-(#2:Exp),
+(cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp)),
-(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp),
-(#2:Exp),
+(cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp)),
-(#2:Exp),
-(cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp)),
+(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp)),
-(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp)),
+(exp(g, n(b, #3:Fresh)) ; b),
-(cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp)),
-(exp(g, n(b, #3:Fresh)) ; b),
+(cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
-(#0:Exp),
-(cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
+(#0:Exp ; cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
-(#0:Exp ; cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b),
+(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
-(sign(sk(a), H(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
+(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
-(sign(sk(b), H(#2:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, #2:Exp) ; exp(g, n(b, #3:Fresh)) ; b))),
+(ok),
-(ok)
|
nil
Maude>
