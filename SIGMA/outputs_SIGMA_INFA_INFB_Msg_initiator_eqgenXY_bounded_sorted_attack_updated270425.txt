nohup: ignoring input
./prueba_SIGMA: 1: datedate: not found
		     \||||||||||||||||||/
		   --- Welcome to Maude ---
		     /||||||||||||||||||\
	     Maude 3.5 built: Sep 25 2024 12:00:00
	     Copyright 1997-2024 SRI International
		   Sun Apr 27 19:07:53 2025
Advisory: "maude-npa.maude", line 14352 (fmod BACK-NARROWING): all the
    variables in the left-hand side of assignment condition fragment M:Msg :=
    downMsgSet(getTerm(metaReduce(removeVariantLabel(clearNonExecEqs(eraseRls(
    onlyEqsNoBuiltInUnify(flipRls(STRAND-EXAMPLE-RULES))))), upTerm(M':Msg))))
    are bound before the matching takes place.
Advisory: "maude-npa.maude", line 14376 (fmod BACK-NARROWING): all the
    variables in the left-hand side of assignment condition fragment M:Msg :=
    downMsgSet(getTerm(metaReduce(removeVariantLabel(clearNonExecEqs(eraseRls(
    onlyEqsNoBuiltInUnify(flipRls(STRAND-EXAMPLE-RULES))))), upTerm(M':Msg))))
    are bound before the matching takes place.
Advisory: "maude-npa.maude", line 14392 (fmod BACK-NARROWING): all the
    variables in the left-hand side of assignment condition fragment M:Msg :=
    downMsgSet(getTerm(metaReduce(removeVariantLabel(clearNonExecEqs(eraseRls(
    onlyEqsNoBuiltInUnify(flipRls(STRAND-EXAMPLE-RULES))))), upTerm(M:Msg))))
    are bound before the matching takes place.

	    Maude-NPA Version: 3.1.4 (June 2nd 2020)
	    with direct composition, irreducibility constraints and time
	    (To be run with Maude 3.0 or above)
	    Copyright (c) 2020, University of Illinois
	    All rights reserved.

 Commands:
 red unification? .           returns the unification algorithm to be used
 red new-strands? .           returns the actual protocol strands
 red displayGrammars .        for generating grammars
 red run(X,Y).                for Y backwards analysis steps for attack pattern
    X
 red debug(X,Y).              more information than run command
 red digest(X,Y).             less information than run command
 red summary(X,Y).            for summary of analysis steps
 red ids(X,Y).                for set of state ids
 red initials(X,Y).           for showing only initial steps
==========================================
reduce in MAUDE-NPA : displayGrammars .
rewrites: 5903292 in 12450ms cpu (12450ms real) (474160 rewrites/second)
result GrammarList: (
grl #0:Msg inL => sign(sk(#1:Name), #0:Msg) inL .  ; 
grl #0:Msg notInI,
   (#0:Msg notLeq #1:Msg ; cp2(#2:Msg, #1:Msg)),
   (#0:Msg notLeq #3:Exp ; #4:Msg ; exp(g, n(#5:Name, #6:Fresh)) ; #5:Name),
   #0:Msg notLeq exp(g, n(#7:Name, #8:Fresh)) ; #7:Name ; #9:Exp ; #10:Msg =>
    H(#0:Msg) inL . )
| (
grl #0:Msg inL => sign(sk(#1:Name), #0:Msg) inL .  ; 
grl #0:Msg notInI,
   #0:Msg notLeq exp(g, n(#1:Name, #2:Fresh)) => (#0:Msg ; #3:Msg) inL . )
| (
grl #0:Msg inL => sign(sk(#1:Name), #0:Msg) inL .  ; 
grl #0:Msg notInI => (#1:Msg ; #0:Msg) inL . )
| (
grl #0:Msg inL => sign(sk(#1:Name), #0:Msg) inL .  ; 
grl ((#0:Msg ; #1:Msg) notLeq #2:Msg ; #3:MsgElem),
   ((#0:Msg ; #1:Msg) notLeq #4:MsgElem ; #5:Msg),
   ((#0:Msg ; #1:Msg) notLeq #6:Msg ; #7:Msg ; #8:MsgElem ; #9:Msg),
   (#0:Msg ; #1:Msg) notLeq #10:Msg ; #11:MsgElem ; #12:Msg ; #13:Msg => (
    #0:Msg ; #1:Msg) inL . )
| (
grl #0:Msg inL => (#1:Msg ; #0:Msg) inL .  ; 
grl #0:Msg inL => (#0:Msg ; #1:Msg) inL .  ; 
grl #0:Msg inL => sign(sk(#1:Name), #0:Msg) inL .  ; 
grl #0:Msg notInI => cp1(#0:Msg, #1:Msg) inL . )
| (
grl #0:Msg inL => (#1:Msg ; #0:Msg) inL .  ; 
grl #0:Msg inL => (#0:Msg ; #1:Msg) inL .  ; 
grl #0:Msg inL => sign(sk(#1:Name), #0:Msg) inL .  ; 
grl #0:Msg notInI => cp1(#1:Msg, #0:Msg) inL . )
| (
grl #0:Msg inL => (#1:Msg ; #0:Msg) inL .  ; 
grl #0:Msg inL => (#0:Msg ; #1:Msg) inL .  ; 
grl #0:Msg inL => sign(sk(#1:Name), #0:Msg) inL .  ; 
grl #0:Msg notInI => cp2(#0:Msg, #1:Msg) inL . )
| (
grl #0:Msg inL => (#1:Msg ; #0:Msg) inL .  ; 
grl #0:Msg inL => (#0:Msg ; #1:Msg) inL .  ; 
grl #0:Msg inL => sign(sk(#1:Name), #0:Msg) inL .  ; 
grl #0:Msg notInI => cp2(#1:Msg, #0:Msg) inL . )
| (
grl #0:Msg inL => (#1:Msg ; #0:Msg) inL .  ; 
grl #0:Msg inL => (#0:Msg ; #1:Msg) inL .  ; 
grl #0:Msg inL => sign(sk(#1:Name), #0:Msg) inL .  ; 
grl #0:Exp inL => exp(#0:Exp, #1:NeNonceSet) inL .  ; 
grl #0:GenvExp notInI => exp(#0:GenvExp, #1:NeNonceSet) inL . )
| (
grl #0:Msg inL => sign(sk(#1:Name), #0:Msg) inL .  ; 
grl n(#0:Name, #1:Fresh) notLeq n(i, #2:Fresh) => n(#0:Name, #1:Fresh) inL . )
| (
grl #0:Msg inL => sign(sk(#1:Name), #0:Msg) inL .  ; 
grl #0:Key notInI,
   #0:Key notLeq sk(#1:Name) => sign(#0:Key, #2:Msg) inL . )
| (
grl #0:Msg inL => sign(sk(#1:Name), #0:Msg) inL .  ; 
grl #0:Msg notInI,
   (#0:Msg notLeq H(#1:Msg ; cp2(exp(g, n(#2:Name, #3:Fresh)) ; #2:Name ;
    #4:Exp ; #5:Msg, #1:Msg))),
   (#0:Msg notLeq H(#6:Msg ; cp2(exp(g, n(#7:Name, #8:Fresh)) ; #7:Name ;
    #9:Exp, #6:Msg))),
   (#0:Msg notLeq H(#10:Exp ; #11:Msg ; exp(g, n(#12:Name, #13:Fresh)) ;
    #12:Name)),
   #0:Msg notLeq H(exp(g, n(#14:Name, #15:Fresh)) ; #14:Name ; #16:Exp ;
    #17:Msg) => sign(#18:Key, #0:Msg) inL . )
| 
grl #0:Msg inL => sign(sk(#1:Name), #0:Msg) inL .  ; 
grl (sign(#0:Key, #1:Msg) notLeq sign(sk(i), #2:Msg)),
   (sign(#0:Key, #1:Msg) notLeq sign(sk(#3:Name), H(#4:Msg ; cp2(exp(g, n(
    #3:Name, #5:Fresh)) ; #3:Name ; #6:Exp, #4:Msg)))),
   (sign(#0:Key, #1:Msg) notLeq sign(sk(#7:Name), H(#8:Msg ; cp2(exp(g, n(
    #7:Name, #9:Fresh)) ; #7:Name ; #10:Exp ; #11:Msg, #8:Msg)))),
   (sign(#0:Key, #1:Msg) notLeq sign(sk(#12:Name), H(#13:Exp ; #14:Msg ; exp(g,
    n(#12:Name, #15:Fresh)) ; #12:Name))),
   sign(#0:Key, #1:Msg) notLeq sign(sk(#16:Name), H(exp(g, n(#16:Name,
    #17:Fresh)) ; #16:Name ; #18:Exp ; #19:Msg)) => sign(#0:Key, #1:Msg) inL . 
==========================================
reduce in MAUDE-NPA : summary(6, 0) .
rewrites: 7554 in 115ms cpu (115ms real) (65686 rewrites/second)
result Summary: States>> 1 Solutions>> 0
==========================================
reduce in MAUDE-NPA : initials(6, 0) .
rewrites: 92 in 0ms cpu (0ms real) (~ rewrites/second)
result IdSystemSet: (empty).IdSystemSet
==========================================
reduce in MAUDE-NPA : summary(6, 1) .
rewrites: 540987 in 904ms cpu (903ms real) (598436 rewrites/second)
result Summary: States>> 2 Solutions>> 0
==========================================
reduce in MAUDE-NPA : initials(6, 1) .
rewrites: 133 in 1ms cpu (0ms real) (133000 rewrites/second)
result IdSystemSet: (empty).IdSystemSet
==========================================
reduce in MAUDE-NPA : summary(6, 2) .
rewrites: 3623764 in 3972ms cpu (3971ms real) (912327 rewrites/second)
result Summary: States>> 7 Solutions>> 0
==========================================
reduce in MAUDE-NPA : initials(6, 2) .
rewrites: 248 in 1ms cpu (0ms real) (248000 rewrites/second)
result IdSystemSet: (empty).IdSystemSet
==========================================
reduce in MAUDE-NPA : summary(6, 3) .
rewrites: 17881014 in 14375ms cpu (14375ms real) (1243896 rewrites/second)
result Summary: States>> 18 Solutions>> 0
==========================================
reduce in MAUDE-NPA : initials(6, 3) .
rewrites: 544 in 0ms cpu (0ms real) (~ rewrites/second)
result IdSystemSet: (empty).IdSystemSet
==========================================
reduce in MAUDE-NPA : summary(6, 4) .
rewrites: 81514374 in 54364ms cpu (54364ms real) (1499418 rewrites/second)
result Summary: States>> 25 Solutions>> 0
==========================================
reduce in MAUDE-NPA : initials(6, 4) .
rewrites: 982 in 1ms cpu (0ms real) (982000 rewrites/second)
result IdSystemSet: (empty).IdSystemSet
==========================================
reduce in MAUDE-NPA : summary(6, 5) .
rewrites: 264826415 in 152373ms cpu (152379ms real) (1738014 rewrites/second)
result Summary: States>> 43 Solutions>> 0
==========================================
reduce in MAUDE-NPA : initials(6, 5) .
rewrites: 1820 in 1ms cpu (1ms real) (1820000 rewrites/second)
result IdSystemSet: (empty).IdSystemSet
==========================================
reduce in MAUDE-NPA : summary(6, 6) .
rewrites: 771409241 in 430915ms cpu (430931ms real) (1790165 rewrites/second)
result Summary: States>> 53 Solutions>> 1
==========================================
reduce in MAUDE-NPA : initials(6, 6) .
rewrites: 2870 in 2ms cpu (1ms real) (1435000 rewrites/second)
result ShortIdSystem: < 1 . 1 . 3 . 2 . 2 . 2 . 1 > (
:: #1:Fresh ::
[ nil | 
   -(exp(g, n(a, #0:Fresh)) ; a), 
   +(exp(g, n(b, #1:Fresh)) ; b), 
   -(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b) eq H(exp(g, n(a,
    #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b), 
   +(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))),
    nil]  & 
:: #0:Fresh ::
[ nil | 
   +(exp(g, n(a, #0:Fresh)) ; a), 
   -(exp(g, n(b, #1:Fresh)) ; b), 
   +(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   -(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   +(ok), nil] )
| 
(exp(g, n(a, #0:Fresh)) ; a) !inI,
(exp(g, n(b, #1:Fresh)) ; b) !inI,
sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b)) !inI,
sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b)) !inI
| 
+(exp(g, n(a, #0:Fresh)) ; a), 
-(exp(g, n(a, #0:Fresh)) ; a), 
+(exp(g, n(b, #1:Fresh)) ; b), 
-(exp(g, n(b, #1:Fresh)) ; b), 
+(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
-(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
+(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
-(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
+(ok)
| 
nil
==========================================
reduce in MAUDE-NPA : summary(6, 7) .
rewrites: 1887034994 in 732657ms cpu (732676ms real) (2575604 rewrites/second)
result Summary: States>> 69 Solutions>> 1
==========================================
reduce in MAUDE-NPA : initials(6, 7) .
rewrites: 4370 in 3ms cpu (2ms real) (1456666 rewrites/second)
result ShortIdSystem: < 1 . 1 . 3 . 2 . 2 . 2 . 1 > (
:: #1:Fresh ::
[ nil | 
   -(exp(g, n(a, #0:Fresh)) ; a), 
   +(exp(g, n(b, #1:Fresh)) ; b), 
   -(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b) eq H(exp(g, n(a,
    #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b), 
   +(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))),
    nil]  & 
:: #0:Fresh ::
[ nil | 
   +(exp(g, n(a, #0:Fresh)) ; a), 
   -(exp(g, n(b, #1:Fresh)) ; b), 
   +(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   -(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   +(ok), nil] )
| 
(exp(g, n(a, #0:Fresh)) ; a) !inI,
(exp(g, n(b, #1:Fresh)) ; b) !inI,
sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b)) !inI,
sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b)) !inI
| 
+(exp(g, n(a, #0:Fresh)) ; a), 
-(exp(g, n(a, #0:Fresh)) ; a), 
+(exp(g, n(b, #1:Fresh)) ; b), 
-(exp(g, n(b, #1:Fresh)) ; b), 
+(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
-(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
+(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
-(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
+(ok)
| 
nil
==========================================
reduce in MAUDE-NPA : summary(6, 8) .
rewrites: 4652444497 in 2886974ms cpu (2886975ms real) (1611529
    rewrites/second)
result Summary: States>> 94 Solutions>> 1
==========================================
reduce in MAUDE-NPA : initials(6, 8) .
rewrites: 6539 in 5ms cpu (5ms real) (1307800 rewrites/second)
result ShortIdSystem: < 1 . 1 . 3 . 2 . 2 . 2 . 1 > (
:: #1:Fresh ::
[ nil | 
   -(exp(g, n(a, #0:Fresh)) ; a), 
   +(exp(g, n(b, #1:Fresh)) ; b), 
   -(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b) eq H(exp(g, n(a,
    #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b), 
   +(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))),
    nil]  & 
:: #0:Fresh ::
[ nil | 
   +(exp(g, n(a, #0:Fresh)) ; a), 
   -(exp(g, n(b, #1:Fresh)) ; b), 
   +(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   -(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   +(ok), nil] )
| 
(exp(g, n(a, #0:Fresh)) ; a) !inI,
(exp(g, n(b, #1:Fresh)) ; b) !inI,
sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b)) !inI,
sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b)) !inI
| 
+(exp(g, n(a, #0:Fresh)) ; a), 
-(exp(g, n(a, #0:Fresh)) ; a), 
+(exp(g, n(b, #1:Fresh)) ; b), 
-(exp(g, n(b, #1:Fresh)) ; b), 
+(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
-(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
+(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
-(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
+(ok)
| 
nil
==========================================
reduce in MAUDE-NPA : summary(6, 9) .
rewrites: 9342581521 in 6668511ms cpu (6668511ms real) (1400999
    rewrites/second)
result Summary: States>> 112 Solutions>> 1
==========================================
reduce in MAUDE-NPA : initials(6, 9) .
rewrites: 9195 in 12ms cpu (11ms real) (766250 rewrites/second)
result ShortIdSystem: < 1 . 1 . 3 . 2 . 2 . 2 . 1 > (
:: #1:Fresh ::
[ nil | 
   -(exp(g, n(a, #0:Fresh)) ; a), 
   +(exp(g, n(b, #1:Fresh)) ; b), 
   -(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b) eq H(exp(g, n(a,
    #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b), 
   +(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))),
    nil]  & 
:: #0:Fresh ::
[ nil | 
   +(exp(g, n(a, #0:Fresh)) ; a), 
   -(exp(g, n(b, #1:Fresh)) ; b), 
   +(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   -(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   +(ok), nil] )
| 
(exp(g, n(a, #0:Fresh)) ; a) !inI,
(exp(g, n(b, #1:Fresh)) ; b) !inI,
sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b)) !inI,
sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b)) !inI
| 
+(exp(g, n(a, #0:Fresh)) ; a), 
-(exp(g, n(a, #0:Fresh)) ; a), 
+(exp(g, n(b, #1:Fresh)) ; b), 
-(exp(g, n(b, #1:Fresh)) ; b), 
+(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
-(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
+(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
-(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
+(ok)
| 
nil
==========================================
reduce in MAUDE-NPA : summary(6, 10) .
rewrites: 15483211886 in 10444919ms cpu (10444919ms real) (1482367
    rewrites/second)
result Summary: States>> 116 Solutions>> 1
==========================================
reduce in MAUDE-NPA : initials(6, 10) .
rewrites: 11952 in 11ms cpu (10ms real) (1086545 rewrites/second)
result ShortIdSystem: < 1 . 1 . 3 . 2 . 2 . 2 . 1 > (
:: #1:Fresh ::
[ nil | 
   -(exp(g, n(a, #0:Fresh)) ; a), 
   +(exp(g, n(b, #1:Fresh)) ; b), 
   -(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b) eq H(exp(g, n(a,
    #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b), 
   +(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))),
    nil]  & 
:: #0:Fresh ::
[ nil | 
   +(exp(g, n(a, #0:Fresh)) ; a), 
   -(exp(g, n(b, #1:Fresh)) ; b), 
   +(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   -(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   +(ok), nil] )
| 
(exp(g, n(a, #0:Fresh)) ; a) !inI,
(exp(g, n(b, #1:Fresh)) ; b) !inI,
sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b)) !inI,
sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b)) !inI
| 
+(exp(g, n(a, #0:Fresh)) ; a), 
-(exp(g, n(a, #0:Fresh)) ; a), 
+(exp(g, n(b, #1:Fresh)) ; b), 
-(exp(g, n(b, #1:Fresh)) ; b), 
+(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
-(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
+(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
-(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
+(ok)
| 
nil
==========================================
reduce in MAUDE-NPA : summary(6, 11) .
rewrites: 28272188887 in 18530248ms cpu (18530247ms real) (1525731
    rewrites/second)
result Summary: States>> 123 Solutions>> 3
==========================================
reduce in MAUDE-NPA : initials(6, 11) .
rewrites: 15112 in 19ms cpu (19ms real) (795368 rewrites/second)
result IdSystemSet: (< 1 . 1 . 3 . 2 . 2 . 2 . 1 > (
:: #1:Fresh ::
[ nil | 
   -(exp(g, n(a, #0:Fresh)) ; a), 
   +(exp(g, n(b, #1:Fresh)) ; b), 
   -(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b) eq H(exp(g, n(a,
    #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b), 
   +(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))),
    nil]  & 
:: #0:Fresh ::
[ nil | 
   +(exp(g, n(a, #0:Fresh)) ; a), 
   -(exp(g, n(b, #1:Fresh)) ; b), 
   +(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   -(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
   +(ok), nil] )
| 
(exp(g, n(a, #0:Fresh)) ; a) !inI,
(exp(g, n(b, #1:Fresh)) ; b) !inI,
sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b)) !inI,
sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b)) !inI
| 
+(exp(g, n(a, #0:Fresh)) ; a), 
-(exp(g, n(a, #0:Fresh)) ; a), 
+(exp(g, n(b, #1:Fresh)) ; b), 
-(exp(g, n(b, #1:Fresh)) ; b), 
+(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
-(sign(sk(a), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
+(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
-(sign(sk(b), H(exp(g, n(a, #0:Fresh)) ; a ; exp(g, n(b, #1:Fresh)) ; b))), 
+(ok)
| 
nil)
(< 1 . 1 . 4 . 1 . 5 . 8 . 11 . 15 . 7 . 1 . 4 . 1 > (
:: nil ::
[ nil | 
   -(#0:Exp), 
   -(exp(g, n(b, #1:Fresh)) ; b), 
   +(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp), nil]  & 
:: nil ::
[ nil | 
   -(#0:Exp), 
   -(cp1(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ;
    #3:Exp)), 
   +(#0:Exp ; cp1(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ;
    a ; #3:Exp)), nil]  & 
:: nil ::
[ nil | 
   -(#3:Exp), 
   -(exp(g, n(a, #2:Fresh)) ; a), 
   +(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp), nil]  & 
:: nil ::
[ nil | 
   -(#3:Exp), 
   -(cp2(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ;
    #3:Exp)), 
   +(#3:Exp ; cp2(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ;
    a ; #3:Exp)), nil]  & 
:: nil ::
[ nil | 
   -(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp), 
   -(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp), 
   +(cp1(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ;
    #3:Exp)), nil]  & 
:: nil ::
[ nil | 
   -(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp), 
   -(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp), 
   +(cp2(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ;
    #3:Exp)), nil]  & 
:: #1:Fresh ::
[ nil | 
   +(exp(g, n(b, #1:Fresh)) ; b), 
   -(#0:Exp ; cp1(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ;
    a ; #3:Exp)), 
   +(sign(sk(b), H(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp ; cp2(exp(g, n(b,
    #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ; #3:Exp)))), nil]  & 
:: #2:Fresh ::
[ nil | 
   +(exp(g, n(a, #2:Fresh)) ; a), 
   -(#3:Exp ; cp2(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ;
    a ; #3:Exp)), 
   +(sign(sk(a), H(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp ; cp2(exp(g, n(b,
    #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ; #3:Exp)))), 
   -(sign(sk(b), H(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp ; cp2(exp(g, n(b,
    #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ; #3:Exp)))), 
   +(ok), nil] )
| 
#0:Exp !inI,
#3:Exp !inI,
(#0:Exp ; cp1(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ;
    #3:Exp)) !inI,
(#3:Exp ; cp2(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ;
    #3:Exp)) !inI,
(exp(g, n(a, #2:Fresh)) ; a) !inI,
(exp(g, n(b, #1:Fresh)) ; b) !inI,
(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp) !inI,
(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp) !inI,
sign(sk(b), H(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp ; cp2(exp(g, n(b, #1:Fresh))
    ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ; #3:Exp))) !inI,
cp1(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ; #3:Exp)
    !inI,
cp2(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ; #3:Exp)
    !inI
| 
+(exp(g, n(a, #2:Fresh)) ; a), 
generatedByIntruder(#3:Exp), 
-(#3:Exp), 
-(exp(g, n(a, #2:Fresh)) ; a), 
+(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp), 
+(exp(g, n(b, #1:Fresh)) ; b), 
generatedByIntruder(#0:Exp), 
-(#0:Exp), 
-(exp(g, n(b, #1:Fresh)) ; b), 
+(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp), 
-(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp), 
-(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp), 
+(cp2(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ;
    #3:Exp)), 
-(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp), 
-(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp), 
+(cp1(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ;
    #3:Exp)), 
-(#3:Exp), 
-(cp2(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ;
    #3:Exp)), 
+(#3:Exp ; cp2(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a
    ; #3:Exp)), 
-(#0:Exp), 
-(cp1(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ;
    #3:Exp)), 
+(#0:Exp ; cp1(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a
    ; #3:Exp)), 
-(#3:Exp ; cp2(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a
    ; #3:Exp)), 
+(sign(sk(a), H(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp ; cp2(exp(g, n(b,
    #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ; #3:Exp)))), 
-(#0:Exp ; cp1(exp(g, n(b, #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a
    ; #3:Exp)), 
+(sign(sk(b), H(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp ; cp2(exp(g, n(b,
    #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ; #3:Exp)))), 
-(sign(sk(b), H(exp(g, n(a, #2:Fresh)) ; a ; #3:Exp ; cp2(exp(g, n(b,
    #1:Fresh)) ; b ; #0:Exp, exp(g, n(a, #2:Fresh)) ; a ; #3:Exp)))), 
+(ok)
| 
nil)
< 1 . 1 . 5 . 1 . 5 . 8 . 11 . 15 . 7 . 1 . 4 . 1 > (
:: nil ::
[ nil | 
   -(#0:Exp), 
   -(exp(g, n(a, #1:Fresh)) ; a), 
   +(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp), nil]  & 
:: nil ::
[ nil | 
   -(#0:Exp), 
   -(cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ;
    #3:Exp)), 
   +(#0:Exp ; cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ;
    b ; #3:Exp)), nil]  & 
:: nil ::
[ nil | 
   -(#3:Exp), 
   -(exp(g, n(b, #2:Fresh)) ; b), 
   +(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp), nil]  & 
:: nil ::
[ nil | 
   -(#3:Exp), 
   -(cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ;
    #3:Exp)), 
   +(#3:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ;
    b ; #3:Exp)), nil]  & 
:: nil ::
[ nil | 
   -(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp), 
   -(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp), 
   +(cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ;
    #3:Exp)), nil]  & 
:: nil ::
[ nil | 
   -(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp), 
   -(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp), 
   +(cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ;
    #3:Exp)), nil]  & 
:: #1:Fresh ::
[ nil | 
   +(exp(g, n(a, #1:Fresh)) ; a), 
   -(#0:Exp ; cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ;
    b ; #3:Exp)), 
   +(sign(sk(a), H(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp ; cp2(exp(g, n(a,
    #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ; #3:Exp)))), 
   -(sign(sk(b), H(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp ; cp2(exp(g, n(a,
    #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ; #3:Exp)))), 
   +(ok), nil]  & 
:: #2:Fresh ::
[ nil | 
   +(exp(g, n(b, #2:Fresh)) ; b), 
   -(#3:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ;
    b ; #3:Exp)), 
   +(sign(sk(b), H(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp ; cp2(exp(g, n(a,
    #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ; #3:Exp)))), nil] )
| 
#0:Exp !inI,
#3:Exp !inI,
(#0:Exp ; cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ;
    #3:Exp)) !inI,
(#3:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ;
    #3:Exp)) !inI,
(exp(g, n(a, #1:Fresh)) ; a) !inI,
(exp(g, n(b, #2:Fresh)) ; b) !inI,
(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp) !inI,
(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp) !inI,
sign(sk(b), H(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp ; cp2(exp(g, n(a, #1:Fresh))
    ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ; #3:Exp))) !inI,
cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ; #3:Exp)
    !inI,
cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ; #3:Exp)
    !inI
| 
+(exp(g, n(b, #2:Fresh)) ; b), 
generatedByIntruder(#3:Exp), 
-(#3:Exp), 
-(exp(g, n(b, #2:Fresh)) ; b), 
+(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp), 
+(exp(g, n(a, #1:Fresh)) ; a), 
generatedByIntruder(#0:Exp), 
-(#0:Exp), 
-(exp(g, n(a, #1:Fresh)) ; a), 
+(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp), 
-(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp), 
-(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp), 
+(cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ;
    #3:Exp)), 
-(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp), 
-(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp), 
+(cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ;
    #3:Exp)), 
-(#3:Exp), 
-(cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ;
    #3:Exp)), 
+(#3:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b
    ; #3:Exp)), 
-(#0:Exp), 
-(cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ;
    #3:Exp)), 
+(#0:Exp ; cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b
    ; #3:Exp)), 
-(#0:Exp ; cp1(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b
    ; #3:Exp)), 
+(sign(sk(a), H(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp ; cp2(exp(g, n(a,
    #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ; #3:Exp)))), 
-(#3:Exp ; cp2(exp(g, n(a, #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b
    ; #3:Exp)), 
+(sign(sk(b), H(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp ; cp2(exp(g, n(a,
    #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ; #3:Exp)))), 
-(sign(sk(b), H(exp(g, n(b, #2:Fresh)) ; b ; #3:Exp ; cp2(exp(g, n(a,
    #1:Fresh)) ; a ; #0:Exp, exp(g, n(b, #2:Fresh)) ; b ; #3:Exp)))), 
+(ok)
| 
nil
==========================================
reduce in MAUDE-NPA : summary(6, 12) .
